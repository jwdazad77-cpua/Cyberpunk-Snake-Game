"""
ULTRA SNAKE - CYBERPUNK EDITION
Python/Pygame Implementation
"""

import pygame
import random
import math
import json
import os
from enum import Enum
from dataclasses import dataclass
from typing import List, Tuple, Optional, Set
from collections import deque

# Initialize Pygame
pygame.init()
pygame.mixer.init()

# ============================================
# CONSTANTS & CONFIGURATION
# ============================================

# Colors (Neon Cyberpunk Theme)
NEON_CYAN = (0, 255, 255)
NEON_PINK = (255, 0, 255)
NEON_PURPLE = (157, 0, 255)
NEON_BLUE = (0, 128, 255)
DARK_BG = (10, 10, 15)
DARKER_BG = (5, 5, 8)
GRID_COLOR = (0, 255, 255, 25)

# Game Settings
GRID_WIDTH = 30
GRID_HEIGHT = 30
CELL_SIZE = 20
FPS = 60

# Game Modes
class GameMode(Enum):
    CLASSIC = {
        'name': 'classic',
        'initial_speed': 8,
        'speed_increase': 0.1,
        'enemy_count': 0,
        'power_ups': True,
        'time_limit': None
    }
    SURVIVAL = {
        'name': 'survival',
        'initial_speed': 10,
        'speed_increase': 0.15,
        'enemy_count': 2,
        'enemy_spawn_rate': 300,
        'power_ups': True,
        'time_limit': None
    }
    TIME_ATTACK = {
        'name': 'time-attack',
        'initial_speed': 12,
        'speed_increase': 0.2,
        'enemy_count': 1,
        'power_ups': True,
        'time_limit': 120  # 2 minutes
    }

# ============================================
# STORAGE MANAGER
# ============================================

class StorageManager:
    @staticmethod
    def get_high_score(mode='classic'):
        try:
            with open('high_scores.json', 'r') as f:
                scores = json.load(f)
                return scores.get(f'highScore_{mode}', 0)
        except FileNotFoundError:
            return 0

    @staticmethod
    def set_high_score(score, mode='classic'):
        scores = {}
        try:
            with open('high_scores.json', 'r') as f:
                scores = json.load(f)
        except FileNotFoundError:
            pass

        key = f'highScore_{mode}'
        current = scores.get(key, 0)
        if score > current:
            scores[key] = score
            with open('high_scores.json', 'w') as f:
                json.dump(scores, f)
            return True
        return False

    @staticmethod
    def get_achievements():
        try:
            with open('achievements.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return []

    @staticmethod
    def unlock_achievement(ach_id, name, description):
        achievements = StorageManager.get_achievements()
        if not any(a['id'] == ach_id for a in achievements):
            achievements.append({
                'id': ach_id,
                'name': name,
                'description': description,
                'unlockedAt': pygame.time.get_ticks()
            })
            with open('achievements.json', 'w') as f:
                json.dump(achievements, f)
            return True
        return False

    @staticmethod
    def get_settings():
        try:
            with open('settings.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {
                'music_volume': 0.5,
                'sfx_volume': 0.7,
                'control_scheme': 'wasd'
            }

    @staticmethod
    def save_settings(settings):
        with open('settings.json', 'w') as f:
            json.dump(settings, f)

# ============================================
# PARTICLE SYSTEM
# ============================================

@dataclass
class Particle:
    x: float
    y: float
    vx: float
    vy: float
    life: float
    decay: float
    color: Tuple[int, int, int]
    size: float

    @classmethod
    def create(cls, x, y, color):
        return cls(
            x=x, y=y,
            vx=(random.random() - 0.5) * 4,
            vy=(random.random() - 0.5) * 4,
            life=1.0,
            decay=0.02 + random.random() * 0.03,
            color=color,
            size=2 + random.random() * 3
        )

    def update(self):
        self.x += self.vx
        self.y += self.vy
        self.life -= self.decay
        self.vx *= 0.98
        self.vy *= 0.98

    def is_dead(self):
        return self.life <= 0

class ParticleSystem:
    def __init__(self):
        self.particles: List[Particle] = []

    def emit(self, x, y, color, count=10):
        for _ in range(count):
            self.particles.append(Particle.create(x, y, color))

    def update(self):
        self.particles = [p for p in self.particles if not p.is_dead()]
        for particle in self.particles:
            particle.update()

    def draw(self, surface, offset_x, offset_y):
        for particle in self.particles:
            alpha = int(255 * particle.life)
            color_with_alpha = (*particle.color, alpha)
            size = int(particle.size)
            x = int(particle.x + offset_x)
            y = int(particle.y + offset_y)
            
            # Draw glowing particle
            glow_surf = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)
            pygame.draw.circle(glow_surf, color_with_alpha, (size, size), size)
            surface.blit(glow_surf, (x - size, y - size), special_flags=pygame.BLEND_ADD)

# ============================================
# SNAKE ENTITY
# ============================================

class Snake:
    def __init__(self, x, y, color=NEON_CYAN, is_player=False):
        self.body = [(x, y)]
        self.direction = (1, 0)
        self.next_direction = (1, 0)
        self.color = color
        self.is_player = is_player
        self.grow_pending = 0
        self.shield_active = False
        self.shield_time = 0
        self.magnet_active = False
        self.magnet_time = 0
        self.dash_cooldown = 0
        self.dash_ready = True

    def update(self):
        # Update timers
        if self.shield_active:
            self.shield_time -= 1
            if self.shield_time <= 0:
                self.shield_active = False

        if self.magnet_active:
            self.magnet_time -= 1
            if self.magnet_time <= 0:
                self.magnet_active = False

        if self.dash_cooldown > 0:
            self.dash_cooldown -= 1
            if self.dash_cooldown == 0:
                self.dash_ready = True

        # Update direction
        self.direction = self.next_direction

        # Move head
        head_x, head_y = self.body[0]
        new_head = (head_x + self.direction[0], head_y + self.direction[1])
        self.body.insert(0, new_head)

        # Grow if needed
        if self.grow_pending > 0:
            self.grow_pending -= 1
        else:
            self.body.pop()

    def grow(self, amount=1):
        self.grow_pending += amount

    def activate_shield(self, duration=300):
        self.shield_active = True
        self.shield_time = duration

    def activate_magnet(self, duration=300):
        self.magnet_active = True
        self.magnet_time = duration

    def dash(self):
        if self.dash_ready:
            for _ in range(3):
                head_x, head_y = self.body[0]
                new_head = (head_x + self.direction[0], head_y + self.direction[1])
                self.body.insert(0, new_head)
                if self.grow_pending == 0:
                    self.body.pop()
            self.dash_cooldown = 180
            self.dash_ready = False
            return True
        return False

    def check_collision(self, grid_width, grid_height, other_snakes=None):
        if other_snakes is None:
            other_snakes = []
        
        head_x, head_y = self.body[0]

        # Wall collision
        if head_x < 0 or head_x >= grid_width or head_y < 0 or head_y >= grid_height:
            return True

        # Self collision
        for segment in self.body[1:]:
            if (head_x, head_y) == segment:
                return True

        # Other snakes collision
        for other_snake in other_snakes:
            if other_snake is self:
                continue
            for segment in other_snake.body:
                if (head_x, head_y) == segment:
                    if not self.shield_active:
                        return True

        return False

    def get_head(self):
        return self.body[0]

# ============================================
# POWER-UP
# ============================================

class PowerUp:
    def __init__(self, x, y, power_type):
        self.x = x
        self.y = y
        self.type = power_type  # 'shield', 'magnet', 'dash', 'slow'
        self.life = 600
        self.pulse = 0.0

    def update(self):
        self.life -= 1
        self.pulse += 0.1

    def is_expired(self):
        return self.life <= 0

    def draw(self, surface, cell_size, offset_x, offset_y):
        x = self.x * cell_size + offset_x
        y = self.y * cell_size + offset_y
        base_size = cell_size * 0.6
        pulse_size = base_size + math.sin(self.pulse) * 5
        center_x = x + cell_size // 2
        center_y = y + cell_size // 2

        color_map = {
            'shield': NEON_CYAN,
            'magnet': NEON_PINK,
            'dash': (255, 255, 0),
            'slow': (0, 255, 0)
        }
        color = color_map.get(self.type, NEON_CYAN)

        # Draw glow
        glow_surf = pygame.Surface((int(pulse_size * 2), int(pulse_size * 2)), pygame.SRCALPHA)
        pygame.draw.circle(glow_surf, (*color, 100), (int(pulse_size), int(pulse_size)), int(pulse_size))
        surface.blit(glow_surf, (center_x - int(pulse_size), center_y - int(pulse_size)), 
                    special_flags=pygame.BLEND_ADD)
        
        # Draw circle
        pygame.draw.circle(surface, color, (center_x, center_y), int(pulse_size / 2), 2)

# ============================================
# AI SYSTEM (A* Pathfinding)
# ============================================

class AStarPathfinder:
    def __init__(self, grid_width, grid_height):
        self.grid_width = grid_width
        self.grid_height = grid_height

    def heuristic(self, a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def get_neighbors(self, node):
        neighbors = []
        directions = [(0, -1), (1, 0), (0, 1), (-1, 0)]
        for dx, dy in directions:
            x, y = node[0] + dx, node[1] + dy
            if 0 <= x < self.grid_width and 0 <= y < self.grid_height:
                neighbors.append((x, y))
        return neighbors

    def find_path(self, start, goal, obstacles):
        open_set = deque([start])
        closed_set = set()
        came_from = {}
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}
        obstacle_set = set(obstacles)

        while open_set:
            current = min(open_set, key=lambda n: f_score.get(n, float('inf')))
            open_set.remove(current)

            if current == goal:
                path = []
                while current in came_from:
                    path.append(current)
                    current = came_from[current]
                path.append(start)
                return list(reversed(path))

            closed_set.add(current)

            for neighbor in self.get_neighbors(current):
                if neighbor in obstacle_set or neighbor in closed_set:
                    continue

                tentative_g_score = g_score[current] + 1

                if neighbor not in open_set:
                    open_set.append(neighbor)
                elif tentative_g_score >= g_score.get(neighbor, float('inf')):
                    continue

                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)

        return None

class EnemySnakeAI:
    def __init__(self, snake, grid_width, grid_height, player_snake=None):
        self.snake = snake
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.player_snake = player_snake
        self.pathfinder = AStarPathfinder(grid_width, grid_height)
        self.current_path = None
        self.path_update_counter = 0
        self.path_update_interval = 5
        self.aggression = 0.5

    def update(self, food, obstacles):
        self.path_update_counter += 1

        if self.path_update_counter >= self.path_update_interval or not self.current_path:
            self.update_path(food, obstacles)
            self.path_update_counter = 0

        if self.current_path and len(self.current_path) > 1:
            next_pos = self.current_path[1]
            head_x, head_y = self.snake.body[0]
            dx = next_pos[0] - head_x
            dy = next_pos[1] - head_y

            if dx > 0:
                self.snake.next_direction = (1, 0)
            elif dx < 0:
                self.snake.next_direction = (-1, 0)
            elif dy > 0:
                self.snake.next_direction = (0, 1)
            elif dy < 0:
                self.snake.next_direction = (0, -1)
        else:
            self.avoidance_behavior(obstacles)

    def update_path(self, food, obstacles):
        head = self.snake.body[0]
        target = food

        if self.player_snake and random.random() < self.aggression:
            target = self.player_snake.body[0]

        obstacle_list = list(obstacles)
        for segment in self.snake.body[1:]:
            obstacle_list.append(segment)
        if self.player_snake:
            for segment in self.player_snake.body:
                obstacle_list.append(segment)

        self.current_path = self.pathfinder.find_path(head, target, obstacle_list)

        if not self.current_path and target != food:
            self.current_path = self.pathfinder.find_path(head, food, obstacle_list)

    def avoidance_behavior(self, obstacles):
        head_x, head_y = self.snake.body[0]
        directions = [(0, -1), (1, 0), (0, 1), (-1, 0)]
        best_dir = self.snake.direction
        best_score = float('-inf')

        for dx, dy in directions:
            next_x, next_y = head_x + dx, head_y + dy

            if not (0 <= next_x < self.grid_width and 0 <= next_y < self.grid_height):
                continue

            is_safe = True
            for obstacle in obstacles:
                if obstacle == (next_x, next_y):
                    is_safe = False
                    break

            for segment in self.snake.body[1:]:
                if segment == (next_x, next_y):
                    is_safe = False
                    break

            if is_safe:
                center_x, center_y = self.grid_width / 2, self.grid_height / 2
                distance_from_center = abs(next_x - center_x) + abs(next_y - center_y)
                score = -distance_from_center

                if score > best_score:
                    best_score = score
                    best_dir = (dx, dy)

        self.snake.next_direction = best_dir

class BossSnakeAI(EnemySnakeAI):
    def __init__(self, snake, grid_width, grid_height, player_snake):
        super().__init__(snake, grid_width, grid_height, player_snake)
        self.aggression = 0.8
        self.attack_pattern = 'chase'
        self.attack_counter = 0

    def update(self, food, obstacles):
        self.attack_counter += 1

        if self.attack_counter % 120 == 0:
            self.attack_pattern = random.choice(['chase', 'ambush', 'block'])

        if self.attack_pattern == 'chase' and self.player_snake:
            head_x, head_y = self.snake.body[0]
            player_x, player_y = self.player_snake.body[0]
            dx = player_x - head_x
            dy = player_y - head_y

            if abs(dx) > abs(dy):
                self.snake.next_direction = (1 if dx > 0 else -1, 0)
            else:
                self.snake.next_direction = (0, 1 if dy > 0 else -1)
        elif self.attack_pattern == 'ambush' and self.player_snake and len(self.player_snake.body) > 1:
            target = self.player_snake.body[1]
            self.update_path(target, obstacles)
        else:
            super().update(food, obstacles)

# ============================================
# AUDIO MANAGER
# ============================================

class AudioManager:
    def __init__(self):
        self.music_volume = 0.5
        self.sfx_volume = 0.7
        self.sound_cache = {}

    def set_music_volume(self, volume):
        self.music_volume = max(0, min(1, volume))
        pygame.mixer.music.set_volume(self.music_volume)

    def set_sfx_volume(self, volume):
        self.sfx_volume = max(0, min(1, volume))

    def play_sound(self, sound_type):
        # Generate procedural sounds using pygame
        # For a full implementation, you'd want to load actual sound files
        # This is a placeholder that uses system beeps
        try:
            if sound_type == 'eat':
                pygame.mixer.Sound.play(pygame.mixer.Sound(buffer=bytes([0] * 1000)))
            elif sound_type == 'powerup':
                pygame.mixer.Sound.play(pygame.mixer.Sound(buffer=bytes([0] * 1000)))
            elif sound_type == 'collision':
                pygame.mixer.Sound.play(pygame.mixer.Sound(buffer=bytes([0] * 1000)))
            elif sound_type == 'dash':
                pygame.mixer.Sound.play(pygame.mixer.Sound(buffer=bytes([0] * 1000)))
        except:
            pass  # Sound system not critical

    def play_music(self):
        # In a full implementation, load and play background music
        # pygame.mixer.music.load('music.mp3')
        # pygame.mixer.music.play(-1)
        pass

    def stop_music(self):
        pygame.mixer.music.stop()

# ============================================
# RENDERER
# ============================================

class Renderer:
    def __init__(self, screen, grid_width, grid_height, cell_size):
        self.screen = screen
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.cell_size = cell_size
        self.padding = 40
        self.screen_shake_x = 0
        self.screen_shake_y = 0
        self.screen_shake_decay = 0.9

    def apply_screen_shake(self, intensity):
        self.screen_shake_x += (random.random() - 0.5) * intensity
        self.screen_shake_y += (random.random() - 0.5) * intensity

    def update_screen_shake(self):
        self.screen_shake_x *= self.screen_shake_decay
        self.screen_shake_y *= self.screen_shake_decay

    def draw_grid(self):
        offset_x = self.padding + int(self.screen_shake_x)
        offset_y = self.padding + int(self.screen_shake_y)

        for x in range(0, self.grid_width * self.cell_size + 1, self.cell_size):
            pygame.draw.line(self.screen, GRID_COLOR[:3], 
                           (x + offset_x, offset_y),
                           (x + offset_x, offset_y + self.grid_height * self.cell_size))

        for y in range(0, self.grid_height * self.cell_size + 1, self.cell_size):
            pygame.draw.line(self.screen, GRID_COLOR[:3],
                           (self.padding + int(self.screen_shake_x), y + offset_y),
                           (self.padding + int(self.screen_shake_x) + self.grid_width * self.cell_size, y + offset_y))

    def draw_snake(self, snake):
        offset_x = self.padding + int(self.screen_shake_x)
        offset_y = self.padding + int(self.screen_shake_y)

        for i, (x, y) in enumerate(snake.body):
            rect_x = x * self.cell_size + offset_x + 2
            rect_y = y * self.cell_size + offset_y + 2
            rect_size = self.cell_size - 4

            if i == 0:  # Head
                # Draw glow
                glow_surf = pygame.Surface((self.cell_size + 20, self.cell_size + 20), pygame.SRCALPHA)
                pygame.draw.rect(glow_surf, (*snake.color, 100), 
                               (10, 10, self.cell_size, self.cell_size))
                self.screen.blit(glow_surf, (rect_x - 10, rect_y - 10), 
                               special_flags=pygame.BLEND_ADD)

                # Draw head
                pygame.draw.rect(self.screen, snake.color, 
                               (rect_x, rect_y, rect_size, rect_size))

                # Draw eyes
                eye_size = 3
                dx, dy = snake.direction
                if dx == 1:
                    pygame.draw.circle(self.screen, (255, 255, 255), 
                                     (rect_x + rect_size - 8, rect_y + 5), eye_size)
                    pygame.draw.circle(self.screen, (255, 255, 255),
                                     (rect_x + rect_size - 8, rect_y + rect_size - 8), eye_size)
                elif dx == -1:
                    pygame.draw.circle(self.screen, (255, 255, 255),
                                     (rect_x + 5, rect_y + 5), eye_size)
                    pygame.draw.circle(self.screen, (255, 255, 255),
                                     (rect_x + 5, rect_y + rect_size - 8), eye_size)
                elif dy == 1:
                    pygame.draw.circle(self.screen, (255, 255, 255),
                                     (rect_x + 5, rect_y + rect_size - 8), eye_size)
                    pygame.draw.circle(self.screen, (255, 255, 255),
                                     (rect_x + rect_size - 8, rect_y + rect_size - 8), eye_size)
                else:
                    pygame.draw.circle(self.screen, (255, 255, 255),
                                     (rect_x + 5, rect_y + 5), eye_size)
                    pygame.draw.circle(self.screen, (255, 255, 255),
                                     (rect_x + rect_size - 8, rect_y + 5), eye_size)
            else:  # Body
                alpha = int(255 * (1 - (i / len(snake.body)) * 0.5))
                body_surf = pygame.Surface((rect_size, rect_size), pygame.SRCALPHA)
                pygame.draw.rect(body_surf, (*snake.color, alpha), (0, 0, rect_size, rect_size))
                self.screen.blit(body_surf, (rect_x, rect_y))

        # Shield effect
        if snake.shield_active:
            head_x, head_y = snake.body[0]
            center_x = head_x * self.cell_size + offset_x + self.cell_size // 2
            center_y = head_y * self.cell_size + offset_y + self.cell_size // 2
            radius = int(self.cell_size * 0.7)
            
            shield_surf = pygame.Surface((radius * 2 + 10, radius * 2 + 10), pygame.SRCALPHA)
            pygame.draw.circle(shield_surf, (*NEON_CYAN, 150), (radius + 5, radius + 5), radius, 3)
            self.screen.blit(shield_surf, (center_x - radius - 5, center_y - radius - 5),
                           special_flags=pygame.BLEND_ADD)

    def draw_food(self, food):
        offset_x = self.padding + int(self.screen_shake_x)
        offset_y = self.padding + int(self.screen_shake_y)

        x = food[0] * self.cell_size + offset_x
        y = food[1] * self.cell_size + offset_y
        pulse = math.sin(pygame.time.get_ticks() / 200) * 3
        size = int(self.cell_size * 0.5 + pulse)
        center_x = x + self.cell_size // 2
        center_y = y + self.cell_size // 2

        # Draw glow
        glow_surf = pygame.Surface((size * 2 + 20, size * 2 + 20), pygame.SRCALPHA)
        pygame.draw.circle(glow_surf, (*NEON_PINK, 150), (size + 10, size + 10), size + 10)
        self.screen.blit(glow_surf, (center_x - size - 10, center_y - size - 10),
                       special_flags=pygame.BLEND_ADD)

        # Draw food
        pygame.draw.circle(self.screen, NEON_PINK, (center_x, center_y), size)

# ============================================
# UI COMPONENTS
# ============================================

class Button:
    def __init__(self, x, y, width, height, text, color=NEON_CYAN):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.color = color
        self.hover = False

    def draw(self, surface, font):
        color = tuple(min(255, c + 50) for c in self.color) if self.hover else self.color
        pygame.draw.rect(surface, color, self.rect, 2)
        
        text_surf = font.render(self.text, True, color)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

    def check_hover(self, pos):
        self.hover = self.rect.collidepoint(pos)
        return self.hover

    def check_click(self, pos):
        return self.rect.collidepoint(pos)

# ============================================
# MAIN GAME CLASS
# ============================================

class UltraSnakeGame:
    def __init__(self):
        self.screen_width = GRID_WIDTH * CELL_SIZE + 80
        self.screen_height = GRID_HEIGHT * CELL_SIZE + 200
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
        pygame.display.set_caption("ULTRA SNAKE - Cyberpunk Edition")
        
        self.clock = pygame.time.Clock()
        self.font_large = pygame.font.Font(None, 48)
        self.font_medium = pygame.font.Font(None, 32)
        self.font_small = pygame.font.Font(None, 24)
        
        self.renderer = Renderer(self.screen, GRID_WIDTH, GRID_HEIGHT, CELL_SIZE)
        self.particle_system = ParticleSystem()
        self.audio_manager = AudioManager()
        
        # Game state
        self.game_state = 'menu'  # menu, mode_select, settings, achievements, playing, paused, gameover
        self.game_mode = None
        self.score = 0
        self.time_elapsed = 0
        self.slow_motion_active = False
        self.slow_motion_time = 0

        # Settings UI state (cached while in settings screen)
        self._settings = StorageManager.get_settings()
        self._settings_dirty = False
        
        # Entities
        self.player_snake = None
        self.enemy_snakes = []
        self.enemy_ais = []
        self.food = None
        self.power_ups = []
        
        # Game loop
        self.frame_count = 0
        self.move_counter = 0
        self.move_interval = 10
        self.speed = 8
        
        # UI
        self.buttons = []
        self.setup_ui()
        
        # Load settings
        self.load_settings()

    def load_settings(self):
        self._settings = StorageManager.get_settings()
        self.audio_manager.set_music_volume(self._settings.get('music_volume', 0.5))
        self.audio_manager.set_sfx_volume(self._settings.get('sfx_volume', 0.7))
        self._settings_dirty = False

    def _save_settings_if_dirty(self):
        if self._settings_dirty:
            StorageManager.save_settings(self._settings)
            self._settings_dirty = False

    def open_settings(self):
        self.load_settings()
        self.game_state = 'settings'

    def open_achievements(self):
        self.game_state = 'achievements'

    def setup_ui(self):
        # Menu buttons will be created dynamically
        pass

    def is_occupied(self, x, y):
        if self.player_snake:
            for segment in self.player_snake.body:
                if segment == (x, y):
                    return True

        for snake in self.enemy_snakes:
            for segment in snake.body:
                if segment == (x, y):
                    return True

        if self.food and self.food == (x, y):
            return True

        for power_up in self.power_ups:
            if power_up.x == x and power_up.y == y:
                return True

        return False

    def spawn_food(self):
        attempts = 0
        while attempts < 100:
            x = random.randint(0, GRID_WIDTH - 1)
            y = random.randint(0, GRID_HEIGHT - 1)
            if not self.is_occupied(x, y):
                self.food = (x, y)
                return
            attempts += 1

    def spawn_power_up(self):
        if not self.game_mode or not self.game_mode.value.get('power_ups', True):
            return
        if random.random() > 0.3:
            return

        attempts = 0
        while attempts < 100:
            x = random.randint(0, GRID_WIDTH - 1)
            y = random.randint(0, GRID_HEIGHT - 1)
            if not self.is_occupied(x, y):
                power_types = ['shield', 'magnet', 'dash', 'slow']
                power_type = random.choice(power_types)
                self.power_ups.append(PowerUp(x, y, power_type))
                return
            attempts += 1

    def start_game(self, mode):
        self.game_mode = mode
        mode_config = mode.value
        self.score = 0
        self.time_elapsed = 0
        self.speed = mode_config['initial_speed']
        self.move_interval = max(1, int(60 / self.speed))
        self.move_counter = 0

        # Initialize entities
        start_x = GRID_WIDTH // 4
        start_y = GRID_HEIGHT // 2
        self.player_snake = Snake(start_x, start_y, NEON_CYAN, True)

        self.enemy_snakes = []
        self.enemy_ais = []
        enemy_count = mode_config.get('enemy_count', 0)

        for i in range(enemy_count):
            enemy_x = GRID_WIDTH * 3 // 4 + (i * 3)
            enemy_y = GRID_HEIGHT // 2 + (i * 2)
            enemy_color = NEON_PINK if i == 0 and enemy_count > 1 else (255, 102, 0)
            enemy_snake = Snake(enemy_x, enemy_y, enemy_color, False)
            self.enemy_snakes.append(enemy_snake)

            if i == 0 and enemy_count > 1:
                self.enemy_ais.append(BossSnakeAI(enemy_snake, GRID_WIDTH, GRID_HEIGHT, self.player_snake))
            else:
                self.enemy_ais.append(EnemySnakeAI(enemy_snake, GRID_WIDTH, GRID_HEIGHT, self.player_snake))

        self.spawn_food()
        self.power_ups = []
        self.game_state = 'playing'
        self.audio_manager.play_music()

    def change_direction(self, new_dir):
        if not self.player_snake:
            return

        current_dir = self.player_snake.direction
        if new_dir[0] == -current_dir[0] and new_dir[1] == -current_dir[1]:
            return

        self.player_snake.next_direction = new_dir

    def update(self):
        if self.game_state != 'playing':
            return

        self.frame_count += 1
        self.move_counter += 1
        self.time_elapsed += 1

        if self.slow_motion_active:
            self.slow_motion_time -= 1
            if self.slow_motion_time <= 0:
                self.slow_motion_active = False
                self.move_interval = max(1, int(60 / self.speed))

        move_interval = self.move_interval * 2 if self.slow_motion_active else self.move_interval

        if self.move_counter >= move_interval:
            self.move_counter = 0

            # Update player
            self.player_snake.update()

            # Update enemies
            for i, enemy in enumerate(self.enemy_snakes):
                if i < len(self.enemy_ais):
                    self.enemy_ais[i].update(self.food, [])
                enemy.update()

            # Check food collision
            if self.player_snake.get_head() == self.food:
                self.player_snake.grow()
                self.score += 10
                self.audio_manager.play_sound('eat')

                # Particle effect
                food_x = self.food[0] * self.renderer.cell_size + self.renderer.padding + self.renderer.cell_size // 2
                food_y = self.food[1] * self.renderer.cell_size + self.renderer.padding + self.renderer.cell_size // 2
                self.particle_system.emit(food_x, food_y, NEON_PINK, 15)

                self.spawn_food()
                self.speed += self.game_mode.value['speed_increase']
                self.move_interval = max(1, int(60 / self.speed))
                self.spawn_power_up()

            # Check power-up collisions
            for i in range(len(self.power_ups) - 1, -1, -1):
                power_up = self.power_ups[i]
                power_up.update()

                if power_up.is_expired():
                    self.power_ups.pop(i)
                    continue

                if self.player_snake.get_head() == (power_up.x, power_up.y):
                    self.audio_manager.play_sound('powerup')

                    if power_up.type == 'shield':
                        self.player_snake.activate_shield(300)
                    elif power_up.type == 'magnet':
                        self.player_snake.activate_magnet(300)
                    elif power_up.type == 'dash':
                        self.player_snake.dash_ready = True
                        self.player_snake.dash_cooldown = 0
                    elif power_up.type == 'slow':
                        self.slow_motion_active = True
                        self.slow_motion_time = 300
                        self.move_interval = self.move_interval * 2

                    self.power_ups.pop(i)

            # Magnet effect
            if self.player_snake.magnet_active and self.food:
                head_x, head_y = self.player_snake.get_head()
                fx, fy = self.food
                dx = head_x - fx
                dy = head_y - fy
                dist = math.sqrt(dx * dx + dy * dy)

                if 0 < dist < 5:
                    if abs(dx) > abs(dy):
                        self.food = (fx + (1 if dx < 0 else -1), fy)
                    else:
                        self.food = (fx, fy + (1 if dy < 0 else -1))

            # Check collisions
            if self.player_snake.check_collision(GRID_WIDTH, GRID_HEIGHT, self.enemy_snakes):
                self.audio_manager.play_sound('collision')
                self.renderer.apply_screen_shake(20)
                self.end_game()
                return

            # Check enemy collisions
            for i in range(len(self.enemy_snakes) - 1, -1, -1):
                enemy = self.enemy_snakes[i]
                if enemy.check_collision(GRID_WIDTH, GRID_HEIGHT, [self.player_snake] + self.enemy_snakes):
                    self.enemy_snakes.pop(i)
                    if i < len(self.enemy_ais):
                        self.enemy_ais.pop(i)
                    self.score += 50

            # Spawn enemies in survival mode
            if self.game_mode == GameMode.SURVIVAL and self.frame_count % self.game_mode.value['enemy_spawn_rate'] == 0:
                if len(self.enemy_snakes) < 5:
                    enemy_x = random.randint(0, GRID_WIDTH - 1)
                    enemy_y = random.randint(0, GRID_HEIGHT - 1)
                    if not self.is_occupied(enemy_x, enemy_y):
                        enemy_snake = Snake(enemy_x, enemy_y, (255, 102, 0), False)
                        self.enemy_snakes.append(enemy_snake)
                        self.enemy_ais.append(EnemySnakeAI(enemy_snake, GRID_WIDTH, GRID_HEIGHT, self.player_snake))

        # Update particles
        self.particle_system.update()
        self.renderer.update_screen_shake()

    def render(self):
        self.screen.fill(DARKER_BG)

        if self.game_state == 'menu':
            self.render_menu()
        elif self.game_state == 'mode_select':
            self.render_mode_select()
        elif self.game_state == 'settings':
            self.render_settings()
        elif self.game_state == 'achievements':
            self.render_achievements()
        elif self.game_state == 'playing' or self.game_state == 'paused':
            self.render_game()
            if self.game_state == 'paused':
                self.render_pause_overlay()
        elif self.game_state == 'gameover':
            self.render_game()
            self.render_gameover_overlay()

    def render_menu(self):
        title = self.font_large.render("ULTRA SNAKE", True, NEON_CYAN)
        subtitle = self.font_medium.render("CYBERPUNK EDITION", True, NEON_PINK)
        high_score = self.font_small.render(f"HIGH SCORE: {StorageManager.get_high_score()}", True, NEON_PINK)

        title_rect = title.get_rect(center=(self.screen_width // 2, 150))
        subtitle_rect = subtitle.get_rect(center=(self.screen_width // 2, 200))
        score_rect = high_score.get_rect(center=(self.screen_width // 2, 250))

        self.screen.blit(title, title_rect)
        self.screen.blit(subtitle, subtitle_rect)
        self.screen.blit(high_score, score_rect)

        # Buttons
        start_btn = Button(self.screen_width // 2 - 100, 300, 200, 40, "START GAME")
        start_btn.draw(self.screen, self.font_medium)

        settings_btn = Button(self.screen_width // 2 - 100, 350, 200, 40, "SETTINGS")
        settings_btn.draw(self.screen, self.font_medium)

        achievements_btn = Button(self.screen_width // 2 - 100, 400, 200, 40, "ACHIEVEMENTS")
        achievements_btn.draw(self.screen, self.font_medium)

        self.buttons = [start_btn, settings_btn, achievements_btn]

    def render_mode_select(self):
        title = self.font_large.render("SELECT MODE", True, NEON_CYAN)
        title_rect = title.get_rect(center=(self.screen_width // 2, 100))
        self.screen.blit(title, title_rect)

        classic_btn = Button(self.screen_width // 2 - 100, 200, 200, 60, "CLASSIC")
        survival_btn = Button(self.screen_width // 2 - 100, 270, 200, 60, "SURVIVAL")
        time_attack_btn = Button(self.screen_width // 2 - 100, 340, 200, 60, "TIME ATTACK")
        back_btn = Button(self.screen_width // 2 - 100, 420, 200, 40, "BACK")

        classic_btn.draw(self.screen, self.font_medium)
        survival_btn.draw(self.screen, self.font_medium)
        time_attack_btn.draw(self.screen, self.font_medium)
        back_btn.draw(self.screen, self.font_medium)

        self.buttons = [classic_btn, survival_btn, time_attack_btn, back_btn]

    def render_settings(self):
        title = self.font_large.render("SETTINGS", True, NEON_CYAN)
        title_rect = title.get_rect(center=(self.screen_width // 2, 100))
        self.screen.blit(title, title_rect)

        music = float(self._settings.get('music_volume', 0.5))
        sfx = float(self._settings.get('sfx_volume', 0.7))
        scheme = self._settings.get('control_scheme', 'wasd')

        # Labels
        music_text = self.font_medium.render(f"MUSIC: {int(music * 100)}%", True, NEON_PINK)
        sfx_text = self.font_medium.render(f"SFX: {int(sfx * 100)}%", True, NEON_PINK)
        scheme_text = self.font_medium.render(f"CONTROLS: {scheme.upper()}", True, NEON_PINK)
        self.screen.blit(music_text, (self.screen_width // 2 - 180, 180))
        self.screen.blit(sfx_text, (self.screen_width // 2 - 180, 260))
        self.screen.blit(scheme_text, (self.screen_width // 2 - 180, 340))

        # Buttons
        music_minus = Button(self.screen_width // 2 + 40, 175, 60, 40, "-")
        music_plus = Button(self.screen_width // 2 + 110, 175, 60, 40, "+")
        sfx_minus = Button(self.screen_width // 2 + 40, 255, 60, 40, "-")
        sfx_plus = Button(self.screen_width // 2 + 110, 255, 60, 40, "+")
        toggle_controls = Button(self.screen_width // 2 - 20, 335, 220, 40, "TOGGLE CONTROLS")
        back_btn = Button(self.screen_width // 2 - 100, 430, 200, 40, "BACK")

        for btn in [music_minus, music_plus, sfx_minus, sfx_plus, toggle_controls, back_btn]:
            btn.draw(self.screen, self.font_medium)

        self.buttons = [music_minus, music_plus, sfx_minus, sfx_plus, toggle_controls, back_btn]

    def render_achievements(self):
        title = self.font_large.render("ACHIEVEMENTS", True, NEON_CYAN)
        title_rect = title.get_rect(center=(self.screen_width // 2, 90))
        self.screen.blit(title, title_rect)

        achievements = StorageManager.get_achievements()
        if not achievements:
            empty_text = self.font_medium.render("No achievements yet. Keep playing.", True, NEON_PINK)
            empty_rect = empty_text.get_rect(center=(self.screen_width // 2, 200))
            self.screen.blit(empty_text, empty_rect)
        else:
            # Show newest first
            achievements = list(reversed(achievements))[:8]
            y = 160
            for a in achievements:
                name = str(a.get('name', ''))
                desc = str(a.get('description', ''))
                line1 = self.font_medium.render(name, True, NEON_PINK)
                line2 = self.font_small.render(desc, True, NEON_CYAN)
                self.screen.blit(line1, (80, y))
                self.screen.blit(line2, (80, y + 28))
                y += 70

        back_btn = Button(self.screen_width // 2 - 100, 500, 200, 40, "BACK")
        back_btn.draw(self.screen, self.font_medium)
        self.buttons = [back_btn]

    def render_game(self):
        self.renderer.draw_grid()

        if self.food:
            self.renderer.draw_food(self.food)

        for power_up in self.power_ups:
            power_up.draw(self.screen, self.renderer.cell_size, 
                        self.renderer.padding, self.renderer.padding)

        for enemy in self.enemy_snakes:
            self.renderer.draw_snake(enemy)

        if self.player_snake:
            self.renderer.draw_snake(self.player_snake)

        self.particle_system.draw(self.screen, self.renderer.padding, self.renderer.padding)

        # UI
        score_text = self.font_medium.render(f"SCORE: {self.score}", True, NEON_CYAN)
        self.screen.blit(score_text, (10, 10))

        if self.game_mode and self.game_mode.value.get('time_limit'):
            time_left = self.game_mode.value['time_limit'] - self.time_elapsed // 60
            time_text = self.font_medium.render(f"TIME: {time_left}", True, NEON_CYAN)
            self.screen.blit(time_text, (10, 50))

    def render_pause_overlay(self):
        overlay = pygame.Surface((self.screen_width, self.screen_height))
        overlay.set_alpha(200)
        overlay.fill(DARK_BG)
        self.screen.blit(overlay, (0, 0))

        pause_text = self.font_large.render("PAUSED", True, NEON_CYAN)
        pause_rect = pause_text.get_rect(center=(self.screen_width // 2, self.screen_height // 2 - 50))
        self.screen.blit(pause_text, pause_rect)

    def render_gameover_overlay(self):
        overlay = pygame.Surface((self.screen_width, self.screen_height))
        overlay.set_alpha(200)
        overlay.fill(DARK_BG)
        self.screen.blit(overlay, (0, 0))

        gameover_text = self.font_large.render("GAME OVER", True, NEON_CYAN)
        score_text = self.font_medium.render(f"SCORE: {self.score}", True, NEON_CYAN)
        high_score_text = self.font_medium.render(
            f"HIGH SCORE: {StorageManager.get_high_score(self.game_mode.value['name'])}", True, NEON_PINK)

        gameover_rect = gameover_text.get_rect(center=(self.screen_width // 2, self.screen_height // 2 - 100))
        score_rect = score_text.get_rect(center=(self.screen_width // 2, self.screen_height // 2 - 30))
        high_rect = high_score_text.get_rect(center=(self.screen_width // 2, self.screen_height // 2 + 10))

        self.screen.blit(gameover_text, gameover_rect)
        self.screen.blit(score_text, score_rect)
        self.screen.blit(high_score_text, high_rect)

    def handle_input(self, event):
        if event.type == pygame.KEYDOWN:
            if self.game_state == 'playing':
                settings = StorageManager.get_settings()
                control_scheme = settings.get('control_scheme', 'wasd')

                if event.key == pygame.K_p or event.key == pygame.K_ESCAPE:
                    self.game_state = 'paused'
                elif event.key == pygame.K_SPACE or event.key == pygame.K_LSHIFT:
                    if self.player_snake:
                        if self.player_snake.dash():
                            self.audio_manager.play_sound('dash')
                elif control_scheme == 'wasd':
                    if event.key == pygame.K_w:
                        self.change_direction((0, -1))
                    elif event.key == pygame.K_s:
                        self.change_direction((0, 1))
                    elif event.key == pygame.K_a:
                        self.change_direction((-1, 0))
                    elif event.key == pygame.K_d:
                        self.change_direction((1, 0))
                else:
                    if event.key == pygame.K_UP:
                        self.change_direction((0, -1))
                    elif event.key == pygame.K_DOWN:
                        self.change_direction((0, 1))
                    elif event.key == pygame.K_LEFT:
                        self.change_direction((-1, 0))
                    elif event.key == pygame.K_RIGHT:
                        self.change_direction((1, 0))
            elif self.game_state == 'paused':
                if event.key == pygame.K_p or event.key == pygame.K_ESCAPE:
                    self.game_state = 'playing'
            elif self.game_state in ['settings', 'achievements', 'mode_select']:
                if event.key == pygame.K_ESCAPE:
                    # ESC always goes back to menu from non-game screens
                    self._save_settings_if_dirty()
                    self.game_state = 'menu'

        elif event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            for button in self.buttons:
                if button.check_click(mouse_pos):
                    if button.text == "START GAME":
                        self.game_state = 'mode_select'
                    elif button.text == "SETTINGS":
                        self.open_settings()
                    elif button.text == "ACHIEVEMENTS":
                        self.open_achievements()
                    elif button.text == "CLASSIC":
                        self.start_game(GameMode.CLASSIC)
                    elif button.text == "SURVIVAL":
                        self.start_game(GameMode.SURVIVAL)
                    elif button.text == "TIME ATTACK":
                        self.start_game(GameMode.TIME_ATTACK)
                    elif button.text == "TOGGLE CONTROLS":
                        current = self._settings.get('control_scheme', 'wasd')
                        self._settings['control_scheme'] = 'arrows' if current == 'wasd' else 'wasd'
                        self._settings_dirty = True
                    elif button.text == "+":
                        # Volume +/- buttons: we disambiguate by button position
                        if button.rect.y < 220:
                            # music
                            v = float(self._settings.get('music_volume', 0.5))
                            v = min(1.0, v + 0.1)
                            self._settings['music_volume'] = round(v, 2)
                            self.audio_manager.set_music_volume(v)
                        else:
                            # sfx
                            v = float(self._settings.get('sfx_volume', 0.7))
                            v = min(1.0, v + 0.1)
                            self._settings['sfx_volume'] = round(v, 2)
                            self.audio_manager.set_sfx_volume(v)
                        self._settings_dirty = True
                    elif button.text == "-":
                        if button.rect.y < 220:
                            v = float(self._settings.get('music_volume', 0.5))
                            v = max(0.0, v - 0.1)
                            self._settings['music_volume'] = round(v, 2)
                            self.audio_manager.set_music_volume(v)
                        else:
                            v = float(self._settings.get('sfx_volume', 0.7))
                            v = max(0.0, v - 0.1)
                            self._settings['sfx_volume'] = round(v, 2)
                            self.audio_manager.set_sfx_volume(v)
                        self._settings_dirty = True
                    elif button.text == "BACK":
                        self._save_settings_if_dirty()
                        self.game_state = 'menu'
                    break

    def end_game(self):
        self.game_state = 'gameover'
        self.audio_manager.stop_music()
        self.audio_manager.play_sound('collision')

        is_new_record = StorageManager.set_high_score(self.score, self.game_mode.value['name'])

        # Check achievements
        if self.score >= 100:
            StorageManager.unlock_achievement('score_100', 'Centurion', 'Score 100 points')
        if self.score >= 500:
            StorageManager.unlock_achievement('score_500', 'Master', 'Score 500 points')

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                else:
                    self.handle_input(event)

            # Update hover states
            if self.game_state in ['menu', 'mode_select', 'settings', 'achievements']:
                mouse_pos = pygame.mouse.get_pos()
                for button in self.buttons:
                    button.check_hover(mouse_pos)

            self.update()
            self.render()

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()

# ============================================
# MAIN ENTRY POINT
# ============================================

if __name__ == "__main__":
    game = UltraSnakeGame()
    game.run()